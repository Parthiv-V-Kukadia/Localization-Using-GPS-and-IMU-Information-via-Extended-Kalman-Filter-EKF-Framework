\begin{lstlisting}
% Implementing EKF for time 2nd UAV take-off and landing where t_min is 10 minutes before UAV taking off and t_max is 5 minutes after landing. From Motor Signal, we can see that UAV took off at 1440 seconds, and landed at 1695 seconds

% Define time interval as provided in the problem statement and define time index to synchronize data between GPS and IMU to align readings based on timestamp
start_t = 1443 - 600; % 10 min before taking-off a second time
start_i = find(t>= start_t,1); % Start time index
end_t = 1685 + 300; % 5 min after landing a second time
end_i = find(t>= end_t,1); % End time index
time_int = t(start_i:end_i); % Define time values from time dataset

% State Variables of interest [NED Position, NED Velocity, Accelerometer Bias]
% x = [x_n, y_n, z_n, v_x, v_y, v_z, b_x, b_y, b_z]
% Define initial state, covariance, and measurement noise covariance
x0 = [x_n(start_i); y_n(start_i); z_n(start_i); 0; 0; 0; 0; 0; 0]; % State
P0 = eye(9); % Covariance
R = diag([eph,eph,epv]) * 1e-3; % Measurement noise covariance, GPS is most reliable
x_hat = zeros(9, length(time_int)); % Create arrays for NED estimate coordinates

% Implementing Extended Kalman Filter - Create System Matrices
for i = start_i:end_i
    dt = (time_int(end) - time_int(1))/(length(time_int)); % Assuming uniform sampling

    % Create Rotation Matrix to move from NED to Ground Frame
    R_NEDtoGround = [cos(psi(i)) * cos(tht(i)) , (cos(psi(i)) * sin(tht(i)) * sin(phi(i))) - (sin(psi(i)) * cos(phi(i))) , (cos(psi(i)) * sin(tht(i)) * cos(phi(i))) + (sin(psi(i)) * sin(phi(i)));
    sin(psi(i)) * cos(tht(i)) , (sin(psi(i)) * sin(tht(i)) * sin(phi(i))) + (cos(psi(i)) * cos(phi(i))) , (sin(psi(i)) * sin(tht(i)) * cos(phi(i))) - (cos(psi(i)) * sin(phi(i)));
    -sin(tht(i)),  cos(tht(i)) * sin(phi(i)),  cos(tht(i)) * cos(phi(i))];
    
    % Create the State Transition Matrix
    F_1 = [eye(3), diag([dt, dt, dt]) , diag([(-dt^2)/2, (-dt^2)/2, (-dt^2)/2]); 
           zeros(3,3) , eye(3), diag([-dt, -dt, -dt])];
    F_2 = [eye(6), zeros(6,3);
           zeros(3,6) , R_NEDtoGround];
    F = [F_1 * F_2         ;  % Upper region of F
         zeros(3,6), eye(3)]; % Lower region of F

    % Define gravity for G matrix
    g = 9.81; % m/s^2

    % Create the Control Input Matrix
    G_1 = [diag([(dt^2)/2, (dt^2)/2 , (dt^2)/2]);
           diag([  dt    ,    dt    ,   dt    ]);
                          zeros(3,3)           ];
    G_2 = [R_NEDtoGround, [0 ; 0 ; g]];
    G = G_1 * G_2;

    % Create process noise covariance matrix
    Q = G * diag([0.7 , 0.4 , 1.5 , 0]) * G'; %qx, qy, qz

    % Prediction Step - using the previous time step to produce an estimation of the state at the current time step
    x_pred = (F * x0) + (G * [acx(i) ; acy(i) ; acz(i) ; 1]);
    P_pred = (F * P0 * F') + Q;

    % Defining the Measurement Model of GPS
    y = [x_n(i+1) ; y_n(i+1) ; z_n(i+1)];

    % To account for the difference in GPS update rate and IMU update rate, need to input a condition such that the GPS update rate is lower to provide long-term position accuracy
    if mod(i, 2) == 0
        % Correction Step with GPS update (every 3rd iteration)
        H = [eye(3), zeros(3, 6)]; % Output Matrix
        S = (H * P_pred * H') + R; % Residual covariance
        W = P_pred * H' * inv(S);  % Optimal Kalman Gain

        % Update step using GPS
        x0 = x_pred + (W * (y - (H * x_pred)));
        P0 = (eye(9) - (W * H)) * P_pred;
        
    else
        % Update step without GPS (IMU update)
        x0 = x_pred;
        P0 = P_pred;
    end

    % Store estimates
    x_hat(:,i) = x0;
end   

% Extract estimated velocities
x_hat = x_hat(:,start_i:end_i);
EKF_pos_N = x_hat(1, :); EKF_pos_E = x_hat(2, :); EKF_pos_D = x_hat(3, :);
EKF_vel_N = x_hat(4, :); EKF_vel_E = x_hat(5, :); EKF_vel_D = x_hat(6, :);
EKF_bx = x_hat(7, :); EKF_by = x_hat(8, :); EKF_bz = x_hat(9, :);

% Calculate NED Velocity and Acceleration from GPS Measurement
dt_v = diff(time_int); dt_a = diff(dt_v);
v_n = diff(x_n(start_i:end_i))./dt_v; a_n = diff(v_n)./dt_a;
v_e = diff(y_n(start_i:end_i))./dt_v; a_e = diff(v_e)./dt_a;
v_d = diff(z_n(start_i:end_i))./dt_v; a_d = diff(v_d)./dt_a;

%% Plot of estimated NED positions based on EKF vs. time
figure; set(gcf,'numbertitle','off','name','EKF Estimated NED Positions');  
subplot(3,1,1); plot(time_int, EKF_pos_N, 'k', time_int, x_n(start_i:end_i), 'r--' ); legend('EKF Estimated', 'NED from GPS');ylabel('North Position, x_n (m)'); grid on;
subplot(3,1,2); plot(time_int, EKF_pos_E, 'k', time_int, y_n(start_i:end_i), 'r--' ); legend('EKF Estimated', 'NED from GPS');ylabel('East Position, y_n (m)'); grid on;
subplot(3,1,3); plot(time_int, EKF_pos_D, 'k', time_int, z_n(start_i:end_i), 'r--' ); legend('EKF Estimated', 'NED from GPS');ylabel('Down Position, z_n (m)'); grid on; xlabel('time (s)');

%% Estimated NED velocities based on EKF Implementation againt time
figure; set(gcf,'numbertitle','off','name','EKF Estimated NED Velocity');  
subplot(3,1,1); plot(time_int(2:end), v_n, 'r--', time_int, EKF_vel_N, 'k' ); legend('EKF Estimated', 'NED from GPS');ylabel('North Velocity, v_xn (m/s)'); grid on;
subplot(3,1,2); plot(time_int(2:end), v_e, 'r--', time_int, EKF_vel_E, 'k' ); legend('EKF Estimated', 'NED from GPS');ylabel('East Velocity, v_yn (m/s)'); grid on;
subplot(3,1,3); plot(time_int(2:end), v_d, 'r--', time_int, EKF_vel_D, 'k'); legend('EKF Estimated', 'NED from GPS');ylabel('Down Velocity, v_zn (m/s)'); grid on; xlabel('Time (s)');

%% Plot of Local NED Acceleration being converted from GPS vs. time
figure; set(gcf,'numbertitle','off','name','NED Acceleration from GPS');  
subplot(3,1,1); plot(time_int(3:end), a_n);ylabel('North Acceleration (a_n, m/s^2)'); grid on;
subplot(3,1,2); plot(time_int(3:end), a_e);ylabel('East Acceleration (a_e, m/s^2)'); grid on;
subplot(3,1,3); plot(time_int(3:end), a_d);ylabel('Down Acceleration (a_d, m/s^2)'); grid on; xlabel('time (s)');

%% Plot of Accelerometer bias from EKF Implementation against time
figure; set(gcf,'numbertitle','off','name','EKF Estimated Accelerometer Bias');  
subplot(3,1,1); plot(time_int, EKF_bx);ylabel('EKF Estimated b_x (m/s^2)'); grid on;
subplot(3,1,2); plot(time_int, EKF_by);ylabel('EKF Estimated b_y (m/s^2)'); grid on;
subplot(3,1,3); plot(time_int, EKF_bz);ylabel('EKF Estimated b_z (m/s^2)'); grid on; xlabel('time (s)');
\end{lstlisting}
\captionof{figure}{MATLAB Code for Implementing EKF to Estimate NED Positions and Velocity}
\label{fig:EKF2NED}
